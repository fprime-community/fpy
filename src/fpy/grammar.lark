# Adapted from: https://docs.python.org/3/reference/grammar.html and the Lark Python grammar

# input is the top-level rule, consisting of zero or more newlines or top level statements
input: (_NEWLINE | _toplevel_stmt)*

# Top-level statements: function definitions OR regular statements
# Function definitions can ONLY appear here, not nested in any control structure
_toplevel_stmt: def_stmt | _stmt

# Regular statements (no function definitions allowed)
_stmt: _small_stmt [_NEWLINE] | _compound_stmt
# small statements are those which cannot themselves contain statements
_small_stmt: expr_stmt | assign_stmt | pass_stmt | break_stmt | continue_stmt | assert_stmt | return_stmt
# compound statements may contain other statements
_compound_stmt: if_stmt | for_stmt | while_stmt | check_stmt

# an indented list of statements which does not define a semantic scope
stmt_list: _NEWLINE _INDENT _stmt+ _DEDENT
# an indented list of statements which does define a semantic scope
block: _NEWLINE _INDENT _stmt+ _DEDENT


# non-compound, non-expr statements. the simplest kind
pass_stmt: "pass"
break_stmt: "break"
continue_stmt: "continue"
assert_stmt: "assert" expr ["," expr]
return_stmt: "return" [expr]
assign_stmt: expr [":" type_name] "=" expr


# the function definition statement
# functions may be defined with zero or more comma-separated parameters, and an
# optional return type annotation. They are followed by an indented, scoped code block
def_stmt: "def" var "(" [parameters] ")" ["->" type_name] ":" block
parameters: parameter ("," parameter)*
# each parameter has a type, and an optional default value expression
parameter: var ":" type_name ["=" expr]


# loop statements
# for loops have a loop variable, a range expression and a list of body statements
for_stmt: "for" var "in" expr ":" stmt_list
# while loops have a conditional expression and a list of body statements
while_stmt: "while" expr ":" stmt_list

# check statement
# check has a conditional, timeout, persist and every expression, a list of body statements,
# and an optional list of timeout body statements
check_stmt: "check" expr "timeout" expr "persist" expr "every" expr ":" stmt_list ["timeout" ":" stmt_list]


# branching statement
# if has a conditional expression and a list of body statements.
# it is followed by zero or more elif clauses, each of which
# have a conditional expression and a list of body statements.
# it is also optionally followed by an else clause, which
# has a list of body statements
if_stmt: "if" expr ":" stmt_list elifs ["else" ":" stmt_list]
elifs: elif_*
elif_: "elif" expr ":" stmt_list

# an expr statement is just an expression "on its own" on the line
?expr_stmt: expr
# an expression is the most complex bit of Fpy syntax.
# the definition of expression encodes the precedence rules and
# associativity for operators, function calls, field accesses,
# and variable accesses
?expr: _test

# the least binding Fpy operation is the logical test (and/or/not)
# logical tests
_test: or_test

# order of binding strength, from least to most: or, and, not
?or_test: or_test OR_OP and_test -> binary_op
        | and_test

?and_test: and_test AND_OP not_test -> binary_op
         | not_test

?not_test: NOT_OP not_test -> unary_op
          | comparison

# all comparison operators (<, >, ==, etc) have same precedence
?comparison: comparison COMPARISON_OP range -> binary_op
           | range

# the range operator has less precedence than comparison but more than arithmetic
# terms
?range: sum RANGE_OPERATOR sum
      | sum

# standard order of operations: PEMDAS, or in reverse as shown here: SADMEP
# subtraction and addition are least binding, followed by mul/div/floor div/modulus,
# followed by unary minus/plus, followed by exponentiation
?sum: sum ADD_OP term -> binary_op
    | sum SUB_OP term -> binary_op
    | term

?term: term MUL_OP factor -> binary_op
     | term DIV_OP factor -> binary_op
     | term FLOOR_DIV_OP factor -> binary_op
     | term MOD_OP factor -> binary_op
     | factor

?factor: ADD_OP factor -> unary_op # unary plus (identity)
       | SUB_OP factor -> unary_op # unary minus (negation)
       | power

?power: atom_expr POW_OP factor -> binary_op
      | atom_expr

# the "indivisible" unit of an expression
?atom_expr: atom_expr "(" [arguments] ")" -> func_call
          | atom_expr "[" expr "]" -> index_expr
          | atom_expr "." name -> member_access
          | _literal
          | "(" expr ")"
          | var
arguments: argument ("," argument)*
argument: name "=" expr -> named_argument
        | expr -> positional_argument

var: name

# Qualified name for types (e.g., Fw.Time, Svc.DpRecord)
# Used in type annotations and return types where only names are allowed
type_name: name ("." name)*

RANGE_OPERATOR: ".."

_literal: number | string | boolean
number: DEC_NUMBER | FLOAT_NUMBER
string: STRING
boolean: CONST_FALSE | CONST_TRUE

# Other terminals

_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

%ignore /[\t \f]+/  // WS
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
%declare _INDENT _DEDENT


# Python terminals

!name: NAME
NAME: /[^\W\d]\w*/
COMMENT: /#[^\n]*/
CONST_TRUE: "True"
CONST_FALSE: "False"
ADD_OP: "+"
SUB_OP: "-"
DIV_OP: "/"
MUL_OP: "*"
FLOOR_DIV_OP: "//"
MOD_OP: "%"
POW_OP: "**"
OR_OP: "or"
AND_OP: "and"
NOT_OP: "not"
COMPARISON_OP: ">" | "<" | "<=" | ">=" | "==" | "!="

STRING: /("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i

# -2 prio so we resolve after floats
DEC_NUMBER.-2:   "1".."9"        ("_"?  "0".."9"                       )*
             |   "0"             ("_"?  "0"                            )* /(?![1-9])/

_SPECIAL_DEC: "0".."9"        ("_"?  "0".."9"                       )*

DECIMAL: "." _SPECIAL_DEC | _SPECIAL_DEC "." _SPECIAL_DEC
_EXP: ("e"|"E") ["+" | "-"] _SPECIAL_DEC
# -1 prio so we resolve the .. syntax in for loop range first
FLOAT_NUMBER.-1: _SPECIAL_DEC _EXP | DECIMAL _EXP?
